To Whom it May Concern:

This is a collection of my favorite projects. Below I have included a short description of the project, and a note of how much code from each file is mine.

Travling Salesman Project (April 2023):

This is a Java project that I worked on for my Evolutionary Computation class. It's a classic problem, but I enjoyed going the extra mile here and paralellize the solution. There was provided code, but I took very little of it, opting to build a solution basically from scratch in order to structure it for parallelization. 

This code runs the traveling salesmam problem many times and collects statistics on the efficiency of the program. It currently displays graphs at the end for the amount of generations and the amount of time in milliseconds each run took. Five test cases run 64 times each. The test cases are for 10 cities, 15 cities, 20 cities, 25 cities, and 30 cities. The number of cities in each test case can easily be controlled by the switch statement at the top of the Main class.
The CityDistances.txt file and the MapBuilder.java file are the only files that are not mine. 



Slime Climb (March 2023):

This is a Unity game, developed as a group project I completed with Lizzy Shackman, Michael Fisher, and Andree Vuong for a Software Development class. The project was a simulation of a software development workflow, and we utilized Scrum, Agile, and KanBan theories and documentations to coordinate our project.

The overall concept of the game was a group effort, and many aspects of the game ended up having multiple hands in them, so attributing work is complicated. I initially worked on player movement, but Michael provided an alternitave approach to jumping mechanics that we ended up using. I worked on player death, but Andree was responsible for the game-over screen, and modified the code to work for his purposes. I aquired the assets for the soundtrack initially, but Lizzy ended up choosing a couple different ones to better match the aesthetic of the art assets she added in later. 

The components of the game that are most fully my own are the level-up and power-up mechanics. Michael drew up the initial concept for blocks snapping to a grid when they landed, but the implementation is fully mine. When a full layer of blocks is completed, a random level-up effect is applied. Michael also was originally responsible for the slime spawning, but I modified that section to incorporate power-ups that would ocassionally fall in place of slimes. The ideas behind the effects of the leveling and powering up are mine with the exception of the invulnerability power up, which was a group idea when I initially pitched power-ups.
This game took effort from everyone, and the above summary does not include the full extent of anyone's responsibilities, including my own. 



Mixed Signals Simulator(February 2022):

This is a C project that I worked on my own time in . The code has some structures in it designed with the possibility of paralelization in mind, but the problem never grew to a size where parallelization was necessary. This project was a basic simulation of random players placing stones in a game I am developing called Mixed Signals, and the 28 statistics I collect are various goals for player-stone patterns that I was testing for how difficult they would be to attain. 

In the game, players do not know the goals they score points with, and they are scored by their opponents. The first several moves are exploratory and basically random, so random players were a mostly effective heuristic. While I have done research since then on more complicated game-evaluation metrics, I have not had the opportunity to implement them yet.

All of the work in this project is fully my own.



Couse Correction(May 2021):

While this is not a coding project, I thought that it was important to include here. This is a board game that I designed a while ago. This is not my most recent game, or the one that I am most proud of, but it is one that is complete enough that I hosted a blind playtest of it. Players who had no idea what the game was came, learned the rules from the rulebook, and played. I recorded the game on camera and talked to the players afterwards to collect feedback for itteration. This is the draft that I made after that playtest.

This game is a racing game that centers around the board game mechanic of "programming," where you lay out a sequence of cards to be enacted in that order. It also simulates inertia, and the combination of these two effects with a chaotic deck of "instructions" makes for a fun game where you are forced to plan for the future, and then regularly see your plans thwarted. 

The only thing not mine in this project is the asteroid artwork and the artworks on the game board. The asteroid artwork is a Creative Commons (CC BY-NC 4.0) image named "Asteroid Photos" by Alexis Bailey. I have not been able to recover the original artworks I used on the gameboard, and did not take note of their attribution when I pulled them into the game. The artworks will be changed on the next draft to images I can responsibly cite.